
void cik_init_sdma_functions(struct si_context *sctx)
{
	sctx->dma_copy = cik_sdma_copy;
}



* sDMA - 系统DMA
* 从CIK（Sea Islands）开始，GPU引入了新的异步DMA引擎。这些引擎用于计算和图形处理。有两个DMA引擎（SDMA0、SDMA1），每个引擎支持一个用于图形处理的环形缓冲区和两个用于计算的队列。
* 编程模型与CP（Command Processor）非常相似（包括环形缓冲区、IB等），但sDMA有自己的数据包格式，与CP使用的PM4格式不同。sDMA支持数据复制、写入嵌入式数据、实心填充以及许多其他操作。它还支持缓冲区的平铺/反铺操作。



dma_cs就是dma ib的命令流它和gfx_cs有着不同的命令形式

## sdma包的定义

针对不同的amdgpu架构，分为si和cik sdma
```c

// sid.h

/* SI异步DMA数据包 */
#define SI_DMA_PACKET(cmd, sub_cmd, n) ((((unsigned)(cmd) & 0xF) << 28) |    \
                                       (((unsigned)(sub_cmd) & 0xFF) << 20) |\
                                       (((unsigned)(n) & 0xFFFFF) << 0))
/* SI异步DMA数据包类型 */
#define SI_DMA_PACKET_WRITE                     0x2
#define SI_DMA_PACKET_COPY                      0x3
#define SI_DMA_COPY_MAX_BYTE_ALIGNED_SIZE       0xfffe0
/* 文档中指出0xffff8是以双字为单位的最大大小，即0x3fffe0字节。 */
#define SI_DMA_COPY_MAX_DWORD_ALIGNED_SIZE      0x3fffe0
#define SI_DMA_COPY_DWORD_ALIGNED               0x00
#define SI_DMA_COPY_BYTE_ALIGNED                0x40
#define SI_DMA_COPY_TILED                       0x8
#define SI_DMA_PACKET_INDIRECT_BUFFER           0x4
#define SI_DMA_PACKET_SEMAPHORE                 0x5
#define SI_DMA_PACKET_FENCE                     0x6
#define SI_DMA_PACKET_TRAP                      0x7
#define SI_DMA_PACKET_SRBM_WRITE                0x9
#define SI_DMA_PACKET_CONSTANT_FILL             0xd
#define SI_DMA_PACKET_NOP                       0xf

/* CIK异步DMA数据包 */
#define CIK_SDMA_PACKET(op, sub_op, n)   ((((unsigned)(n) & 0xFFFF) << 16) |	\
					 (((unsigned)(sub_op) & 0xFF) << 8) |	\
					 (((unsigned)(op) & 0xFF) << 0))
/* CIK异步DMA数据包类型 */
#define    CIK_SDMA_OPCODE_NOP                     0x0
#define    CIK_SDMA_OPCODE_COPY                    0x1
#define        CIK_SDMA_COPY_SUB_OPCODE_LINEAR            0x0
#define        CIK_SDMA_COPY_SUB_OPCODE_TILED             0x1
#define        CIK_SDMA_COPY_SUB_OPCODE_SOA               0x3
#define        CIK_SDMA_COPY_SUB_OPCODE_LINEAR_SUB_WINDOW 0x4
#define        CIK_SDMA_COPY_SUB_OPCODE_TILED_SUB_WINDOW  0x5
#define        CIK_SDMA_COPY_SUB_OPCODE_T2T_SUB_WINDOW    0x6
#define    CIK_SDMA_OPCODE_WRITE                   0x2
#define        SDMA_WRITE_SUB_OPCODE_LINEAR               0x0
#define        SDMA_WRTIE_SUB_OPCODE_TILED                0x1
#define    CIK_SDMA_OPCODE_INDIRECT_BUFFER         0x4
#define    CIK_SDMA_PACKET_FENCE                   0x5
#define    CIK_SDMA_PACKET_TRAP                    0x6
#define    CIK_SDMA_PACKET_SEMAPHORE               0x7
#define    CIK_SDMA_PACKET_CONSTANT_FILL           0xb
#define    CIK_SDMA_OPCODE_TIMESTAMP               0xd
#define        SDMA_TS_SUB_OPCODE_SET_LOCAL_TIMESTAMP     0x0
#define        SDMA_TS_SUB_OPCODE_GET_LOCAL_TIMESTAMP     0x1
#define        SDMA_TS_SUB_OPCODE_GET_GLOBAL_TIMESTAMP    0x2
#define    CIK_SDMA_PACKET_SRBM_WRITE              0xe
/* 有一个未记录的硬件“特性”阻止HW从(1 << 22)的256字节之后进行复制 */
#define    CIK_SDMA_COPY_MAX_SIZE                  0x3fff00

由于调试时使用的amdgpu为vi系列，使用的sdma为cik 

```
## 创建 


```
static struct pipe_context *si_create_context(struct pipe_screen *screen,
                                              unsigned flags)
    ...

	if (sctx->chip_class >= CIK)
		cik_init_sdma_functions(sctx);
	else
		si_init_dma_functions(sctx);

    // num_sdma_rings 在winsys创建时通过ac_gpu_info获取gpu信息，no_async_dma即为nodma
	if (sscreen->info.num_sdma_rings && !(sscreen->debug_flags & DBG(NO_ASYNC_DMA))) {
		sctx->dma_cs = sctx->ws->cs_create(sctx->ctx, RING_DMA,
						       (void*)si_flush_dma_cs,
						       sctx);
	}
    ...
}
```
* 调试时所用chip为vi ，所以分析cik sdma
* 调用cs_create通过将ring_type 设置成RING_DMA，下发ib时，gpu即可识别出此次ib属于哪种ring类型


通过si_test_dma来分析测试si中的dma


设置环境变量   
R600_DEBUG=testdma


## dma下发缓冲数据

dma下发提供的接口是一个dma_copy接口

```

void cik_init_sdma_functions(struct si_context *sctx)
{
	sctx->dma_copy = cik_sdma_copy;
}


static void cik_sdma_copy(struct pipe_context *ctx,
			  struct pipe_resource *dst,
			  unsigned dst_level,
			  unsigned dstx, unsigned dsty, unsigned dstz,
			  struct pipe_resource *src,
			  unsigned src_level,
			  const struct pipe_box *src_box)
{
    // 处理buffer
	if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
		cik_sdma_copy_buffer(sctx, dst, src, dstx, src_box->x, src_box->width);
		return;
	}
    // 处理纹理

	if ((sctx->chip_class == CIK || sctx->chip_class == VI) &&
	    cik_sdma_copy_texture(sctx, dst, dst_level, dstx, dsty, dstz,
				  src, src_level, src_box))
		return;

fallback:
	si_resource_copy_region(ctx, dst, dst_level, dstx, dsty, dstz,
				src, src_level, src_box);
}

static void cik_sdma_copy_buffer(struct si_context *ctx,
                                 struct pipe_resource *dst,
                                 struct pipe_resource *src,
                                 uint64_t dst_offset,
                                 uint64_t src_offset,
                                 uint64_t size)
{
    // 获取DMA命令流
    struct radeon_cmdbuf *cs = ctx->dma_cs;
    unsigned i, ncopy, csize;
    struct r600_resource *rdst = r600_resource(dst);
    struct r600_resource *rsrc = r600_resource(src);

    // 标记目标缓冲区范围为有效（已初始化），
    // 这样在映射该范围时，transfer_map就知道它应该等待GPU。
    util_range_add(&rdst->valid_buffer_range, dst_offset,
                   dst_offset + size);

    // 更新偏移以获得GPU地址
    dst_offset += rdst->gpu_address;
    src_offset += rsrc->gpu_address;

    // 计算拷贝次数
    ncopy = DIV_ROUND_UP(size, CIK_SDMA_COPY_MAX_SIZE);
    // 确保有足够的DMA空间
    si_need_dma_space(ctx, ncopy * 7, rdst, rsrc);

    // 遍历拷贝次数
    for (i = 0; i < ncopy; i++) {
        // 计算当前拷贝的大小
        csize = MIN2(size, CIK_SDMA_COPY_MAX_SIZE);
        // 发送SDMA拷贝命令
        radeon_emit(cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
                                        CIK_SDMA_COPY_SUB_OPCODE_LINEAR,
                                        0));
        radeon_emit(cs, ctx->chip_class >= GFX9 ? csize - 1 : csize);
        radeon_emit(cs, 0); /* src/dst endian swap */
        radeon_emit(cs, src_offset);
        radeon_emit(cs, src_offset >> 32);
        radeon_emit(cs, dst_offset);
        radeon_emit(cs, dst_offset >> 32);
        // 更新偏移和大小
        dst_offset += csize;
        src_offset += csize;
        size -= csize;
    }
}


void si_need_dma_space(struct si_context *ctx, unsigned num_dw,
                       struct r600_resource *dst, struct r600_resource *src)
{
    // 计算当前DMA命令流的VRAM和GTT使用量
    uint64_t vram = ctx->dma_cs->used_vram;
    uint64_t gtt = ctx->dma_cs->used_gart;

    // 如果目标缓冲存在，添加其VRAM和GTT使用量
    if (dst) {
        vram += dst->vram_usage;
        gtt += dst->gart_usage;
    }
    // 如果源缓冲存在，添加其VRAM和GTT使用量
    if (src) {
        vram += src->vram_usage;
        gtt += src->gart_usage;
    }

    // 如果DMA命令流中包含了GFX IB，并且该IB被DMA所依赖， // 则刷新GFX IB
    if (radeon_emitted(ctx->gfx_cs, ctx->initial_gfx_cs_size) &&
        ((dst &&
          ctx->ws->cs_is_buffer_referenced(ctx->gfx_cs, dst->buf,
                                           RADEON_USAGE_READWRITE)) ||
         (src &&
          ctx->ws->cs_is_buffer_referenced(ctx->gfx_cs, src->buf,
                                           RADEON_USAGE_WRITE))))
        si_flush_gfx_cs(ctx, RADEON_FLUSH_ASYNC_START_NEXT_GFX_IB_NOW, NULL);

    // 如果DMA空间不足，或者内存使用量超过限制，则刷新DMA命令流
    num_dw++; /* 用于下面的emit_wait_idle */
    if (!ctx->ws->cs_check_space(ctx->dma_cs, num_dw) ||
        ctx->dma_cs->used_vram + ctx->dma_cs->used_gart > 64 * 1024 * 1024 ||
        !radeon_cs_memory_below_limit(ctx->screen, ctx->dma_cs, vram, gtt)) {
        si_flush_dma_cs(ctx, PIPE_FLUSH_ASYNC, NULL);
        assert((num_dw + ctx->dma_cs->current.cdw) <= ctx->dma_cs->current.max_dw);
    }

    // 如果目标或源缓冲曾经在IB中被使用，则等待空闲
    if ((dst &&
         ctx->ws->cs_is_buffer_referenced(ctx->dma_cs, dst->buf,
                                          RADEON_USAGE_READWRITE)) ||
        (src &&
         ctx->ws->cs_is_buffer_referenced(ctx->dma_cs, src->buf,
                                          RADEON_USAGE_WRITE)))
        si_dma_emit_wait_idle(ctx);

    // 将目标和源缓冲添加到DMA命令流的buffer list中
    if (dst) {
        radeon_add_to_buffer_list(ctx, ctx->dma_cs, dst,
                                  RADEON_USAGE_WRITE, 0);
    }
    if (src) {
        radeon_add_to_buffer_list(ctx, ctx->dma_cs, src,
                                  RADEON_USAGE_READ, 0);
    }

    // 增加DMA调用计数
    ctx->num_dma_calls++;
}

static void si_dma_emit_wait_idle(struct si_context *sctx)
{
	struct radeon_cmdbuf *cs = sctx->dma_cs;

	/* NOP waits for idle. */
	if (sctx->chip_class >= CIK)
		radeon_emit(cs, 0x00000000); /* NOP */
	else
		radeon_emit(cs, 0xf0000000); /* NOP */
}
```
struct radeon_cmdbuf		*dma_cs;


# 调试

调试直接打开R600_DEBUG=testdma

通过si提供的si_test_dma来测试

```
void si_test_dma(struct si_screen *sscreen)
{
    // 创建图形和上下文
    struct pipe_screen *screen = &sscreen->b;
    struct pipe_context *ctx = screen->context_create(screen, NULL, 0);
    struct si_context *sctx = (struct si_context*)ctx;
    uint64_t max_alloc_size;
    unsigned i, iterations, num_partial_copies, max_levels, max_tex_side;
    unsigned num_pass = 0, num_fail = 0;

    // 设置测试参数
    max_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
    max_tex_side = 1 << (max_levels - 1);
    max_alloc_size = 128 * 1024 * 1024;  // 最大内存限制为128MB
    iterations = 1000000000;  // 迭代次数
    num_partial_copies = 30;  // 部分拷贝次数

    // 随机生成测试用例
    for (i = 0; i < iterations; i++) {
        struct pipe_resource tsrc = {}, tdst = {}, *src, *dst;
        struct si_texture *sdst;
        struct si_texture *ssrc;
        struct cpu_texture src_cpu, dst_cpu;
        unsigned bpp, max_width, max_height, max_depth, j, num;
        unsigned gfx_blits = 0, dma_blits = 0, max_tex_side_gen;
        unsigned max_tex_layers;
        bool pass;
        bool do_partial_copies = rand() & 1;

        // 生成随机测试用例
        tsrc.target = tdst.target = PIPE_TEXTURE_2D_ARRAY;
        tsrc.depth0 = tdst.depth0 = 1;

        bpp = 1 << (rand() % 5);
        tsrc.format = tdst.format = get_format_from_bpp(bpp);

        max_tex_side_gen = generate_max_tex_side(max_tex_side);
        max_tex_layers = rand() % 4 ? 1 : 5;

        tsrc.width0 = (rand() % max_tex_side_gen) + 1;
        tsrc.height0 = (rand() % max_tex_side_gen) + 1;
        tsrc.array_size = (rand() % max_tex_layers) + 1;

        // 有1/4的机会生成2的幂次方维度
        if (rand() % 4 == 0) {
            tsrc.width0 = util_next_power_of_two(tsrc.width0);
            tsrc.height0 = util_next_power_of_two(tsrc.height0);
        }

        if (!do_partial_copies) {
            // 只有整个表面的拷贝，维度相同
            tdst = tsrc;
        } else {
            max_tex_side_gen = generate_max_tex_side(max_tex_side);
            max_tex_layers = rand() % 4 ? 1 : 5;

            // 多次部分拷贝，维度可以不同
            tdst.width0 = (rand() % max_tex_side_gen) + 1;
            tdst.height0 = (rand() % max_tex_side_gen) + 1;
            tdst.array_size = (rand() % max_tex_layers) + 1;

            // 有1/4的机会生成2的幂次方维度
            if (rand() % 4 == 0) {
                tdst.width0 = util_next_power_of_two(tdst.width0);
                tdst.height0 = util_next_power_of_two(tdst.height0);
            }
        }

        // 检查纹理大小
        if ((uint64_t)tsrc.width0 * tsrc.height0 * tsrc.array_size * bpp +
            (uint64_t)tdst.width0 * tdst.height0 * tdst.array_size * bpp >
            max_alloc_size) {
            // 太大，重试
            i--;
            continue;
        }

        // 使用VRAM（所有tiling模式）和GTT（staging，仅线性）分配纹理
        tsrc.usage = rand() % 4 ? PIPE_USAGE_DEFAULT : PIPE_USAGE_STAGING;
        tdst.usage = rand() % 4 ? PIPE_USAGE_DEFAULT : PIPE_USAGE_STAGING;

        // 分配纹理资源（GPU和CPU的拷贝）
        src = screen->resource_create(screen, &tsrc);
        dst = screen->resource_create(screen, &tdst);
        assert(src);
        assert(dst);
        sdst = (struct si_texture*)dst;
        ssrc = (struct si_texture*)src;
        alloc_cpu_texture(&src_cpu, &tsrc, bpp);
        alloc_cpu_texture(&dst_cpu, &tdst, bpp);

        printf("%4u: dst = (%5u x %5u x %u, %s), "
               " src = (%5u x %5u x %u, %s), bpp = %2u, ",
               i, tdst.width0, tdst.height0, tdst.array_size,
               array_mode_to_string(sscreen, &sdst->surface),
               tsrc.width0, tsrc.height0, tsrc.array_size,
               array_mode_to_string(sscreen, &ssrc->surface), bpp);
        fflush(stdout);

        // 设置源像素
        set_random_pixels(ctx, src, &src_cpu);

        // 清空目标像素
        uint32_t zero = 0;
        si_clear_buffer(sctx, dst, 0, sdst->surface.surf_size, &zero, 4,
                        SI_COHERENCY_SHADER);
        memset(dst_cpu.ptr, 0, dst_cpu.layer_stride * tdst.array_size);

        // 准备测试数据
        max_width = MIN2(tsrc.width0, tdst.width0);
        max_height = MIN2(tsrc.height0, tdst.height0);
        max_depth = MIN2(tsrc.array_size, tdst.array_size);

        num = do_partial_copies ? num_partial_copies : 1;
        for (j = 0; j < num; j++) {
            int width, height, depth;
            int srcx, srcy, srcz, dstx, dsty, dstz;
            struct pipe_box box;
            unsigned old_num_draw_calls = sctx->num_draw_calls;
            unsigned old_num_dma_calls = sctx->num_dma_calls;

            if (!do_partial_copies) {
                // 拷贝整个源到目标
                width = max_width;
                height = max_height;
                depth = max_depth;

                srcx = srcy = srcz = dstx = dsty = dstz = 0;
            } else {
                // 从源到目标进行随机子矩形拷贝
                depth = (rand() % max_depth) + 1;
                srcz = rand() % (tsrc.array_size - depth + 1);
                dstz = rand() % (tdst.array_size - depth + 1);

                // 针对平铺部分拷贝的特殊代码路径
                if (!ssrc->surface.is_linear &&
                    !sdst->surface.is_linear &&
                    rand() & 1) {
                    if (max_width < 8 || max_height < 8)
                        continue;
                    width = ((rand() % (max_width / 8)) + 1) * 8;
                    height = ((rand() % (max_height / 8)) + 1) * 8;

                    srcx = rand() % (tsrc.width0 - width + 1) & ~0x7;
                    srcy = rand() % (tsrc.height0 - height + 1) & ~0x7;

                    dstx = rand() % (tdst.width0 - width + 1) & ~0x7;
                    dsty = rand() % (tdst.height0 - height + 1) & ~0x7;
                } else {
                    // 确保不会除以零
                    assert(max_width > 0 && max_height > 0);

                    width = (rand() % max_width) + 1;
                    height = (rand() % max_height) + 1;

                    srcx = rand() % (tsrc.width0 - width + 1);
                    srcy = rand() % (tsrc.height0 - height + 1);

                    dstx = rand() % (tdst.width0 - width + 1);
                    dsty = rand() % (tdst.height0 - height + 1);
                }

                // 针对L2T的超出边界读取的特殊代码路径
                if (ssrc->surface.is_linear &&
                    !sdst->surface.is_linear &&
                    rand() % 4 == 0) {
                    srcx = 0;
                    srcy = 0;
                    srcz = 0;
                }
            }

            // GPU拷贝
            u_box_3d(srcx, srcy, srcz, width, height, depth, &box);
            sctx->dma_copy(ctx, dst, 0, dstx, dsty, dstz, src, 0, &box);

            // 查看使用了哪个引擎
            gfx_blits += sctx->num_draw_calls > old_num_draw_calls;
            dma_blits += sctx->num_dma_calls > old_num_dma_calls;

            // CPU拷贝
            util_copy_box(dst_cpu.ptr, tdst.format, dst_cpu.stride,
                          dst_cpu.layer_stride,
                          dstx, dsty, dstz, width, height, depth,
                          src_cpu.ptr, src_cpu.stride,
                          src_cpu.layer_stride,
                          srcx, srcy, srcz);
        }

        // 比较纹理数据
        pass = compare_textures(ctx, dst, &dst_cpu, bpp);
        if (pass)
            num_pass++;
        else
            num_fail++;

        printf("BLITs: GFX = %2u, DMA = %2u, %s [%u/%u]\n",
               gfx_blits, dma_blits, pass ? "pass" : "fail",
               num_pass, num_pass+num_fail);

        // 清理资源
        pipe_resource_reference(&src, NULL);
        pipe_resource_reference(&dst, NULL);
        free(src_cpu.ptr);
        free(dst_cpu.ptr);
    }

    ctx->destroy(ctx);
    exit(0);
}
```
