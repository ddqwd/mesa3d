# 规范 

光栅化是将一个基本图元转换为二维图像的过程。图像中的每个点包含颜色和深度等信息。光栅化一个基本图元的过程始于确定哪些整数网格中的方格在窗口坐标中被该基本图元占用，并为每个这样的方格分配深度值。这个过程在点、线和三角形基本图元的情况下在14.1-14.6节中有详细描述。

一个网格方格，包括其（x，y）窗口坐标、z（深度）以及由片段着色器可能添加的相关数据，被称为一个片段。一个片段通过其左下角来定位，该角位于整数网格坐标上。

光栅化操作还涉及到片段的中心，其偏移了（1/2, 1/2）从其左下角（因此位于半整数坐标上）。

片段实际上不需要是正方形的，光栅化规则不受片段的宽高比的影响。然而，显示非正方形的网格会导致光栅化的点和线段在一个方向上看起来比另一个方向上更宽。

我们假设片段是正方形的，因为这样可以简化抗锯齿和纹理处理。

在光栅化之后，片段将经过14.9节中描述的早期片段测试的处理，这些测试可以修改或丢弃片段。生存下来的片段将由片段着色器（参见第15章）进行处理。片段着色器确定片段的颜色值，还可以修改或替换其分配的深度值。

图14.1展示了光栅化过程。

一个网格方格以及其深度和着色器输出参数被称为一个片段；这些参数一起被称为片段的相关数据。片段通过其左下角来定位，该角位于整数网格坐标上。

光栅化操作还涉及到片段的中心，该中心从片段的左下角偏移（1/2，1/2），因此位于半整数坐标上。

在OpenGL中，网格方格实际上不需要是正方形。光栅化规则不受网格方格的实际宽高比的影响。然而，显示非正方形的网格会导致光栅化的点和线段在一个方向上看起来比另一个方向上更宽。我们假设片段是正方形的，因为这样可以简化抗锯齿和纹理处理。

光栅化受到多种因素的影响。在光栅化之前，图元可能会被丢弃。点可能具有不同的直径，线段可能具有不同的宽度。点、线段或多边形可以进行抗锯齿处理。

光栅化只会生成与帧缓冲中的像素对应的片段。那些根据下面描述的任何原始光栅化规则而产生的片段，但位于帧缓冲之外的片段不会被产生，也不会被GL的任何后续阶段处理，包括第14.9节中描述的早期片段测试中的任何阶段。

## 在进行光栅化之前丢弃基本图元

被发送到顶点流零（参见第13.2节）的基本图元将进一步处理；而被发射到任何其他流的基本图元将被丢弃。当禁用几何着色器时，所有顶点都被视为发射到流零。

在进行光栅化之前，可以选择丢弃基本图元，通过调用具有目标RASTERIZER_DISCARD的Enable和Disable来实现。当启用时，基本图元将在光栅化阶段之前立即被丢弃，但在可选的变换反馈阶段之后（参见第13.2节）。当禁用时，基本图元将传递到光栅化阶段，以便正常处理。启用RASTERIZER_DISCARD还会导致忽略Clear和ClearBuffer*命令。

控制基本图元丢弃所需的状态是一个位，指示丢弃是否已启用或禁用。基本图元丢弃的初始值为FALSE。


## 14.2 不变性

考虑一个基本图元p0，通过在窗口坐标中沿偏移（x，y）来平移一个基本图元p获得，其中x和y是整数。只要p0和p都没有被裁剪，那么每个从p0产生的片段f0都必须与从p产生的相应片段f相同，只是f0的中心从f的中心偏移了（x，y）。


## 14.3 抗锯齿

光栅化片段的R、G和B值保持不变，但A值将乘以一个范围在[0, 1]内的浮点值，描述了片段的屏幕像素覆盖。GL的每片段阶段可以配置为使用A值来混合传入的片段与帧缓冲中已存在的相应像素。

关于如何计算抗锯齿片段覆盖值的细节很难一般性地规定。原因在于高质量的抗锯齿可能要考虑到感知问题以及帧缓冲内容显示的显示器特性。这些细节无法在本文档的范围内详细描述。此外，某个基本图元的片段计算的覆盖值可能依赖于与与片段对应的网格方格相邻的多个网格方格之间的关系，而不仅仅取决于片段所在的网格方格。另一个考虑因素是精确计算覆盖值可能会具有较高的计算成本；因此，我们允许给定的GL实现通过使用快速但不完全准确的覆盖计算来近似真实的覆盖值。

考虑到这些因素，我们选择在原型情况下规定了精确抗锯齿的行为，其中每个显示的像素都是均匀强度的完美正方形。这个正方形被称为片段方格，具有左下角(x, y)和右上角(x+1, y+1)。我们认识到这个简单的方框滤波器可能不会产生最有利的抗锯齿结果，但它提供了一个简单而明确定义的模型。

一个GL实现可以使用其他方法来执行抗锯齿，但必须满足以下条件：
1. 如果f1和f2是两个片段，并且f1的某个部分被某个基本图元覆盖，是f2被该基本图元覆盖的相应部分的子集，那么为f1计算的覆盖必须小于或等于为f2计算的覆盖。
2. 片段f的覆盖计算必须是局部的：它只能依赖于f与正在光栅化的基本图元边界的关系，不能依赖于f的x和y坐标。

另一个希望但不是必须的属性是：
3. 由光栅化特定基本图元产生的所有片段的覆盖值之和必须是恒定的，独立于窗口坐标的任何刚体运动，只要这些片段都不位于窗口边缘上。

在某些实现中，可以通过提供GL提示（第21.5节）来获得不同质量的抗锯齿效果，从而允许用户在图像质量与速度之间进行权衡。


## 14.3.1 多重采样

多重采样是一种用于对GL中的所有基本图元（点、线和多边形）进行抗锯齿处理的机制。该技术是在每个像素点上多次对所有基本图元进行采样。颜色样本值在每次像素更新时解析为单个可显示的颜色，因此在应用程序级别看起来抗锯齿处理是自动的。

由于每个样本包含颜色、深度和模板信息，因此颜色（包括纹理操作）、深度和模板函数在多重采样模式下与单样本模式等效。

另外，帧缓冲区中添加了一个额外的缓冲区，称为多重采样缓冲区。像素样本值，包括颜色、深度和模板值，都存储在这个缓冲区中。样本包含了每个片段颜色的单独颜色值。当帧缓冲区包括多重采样缓冲区时，它不包括深度或模板缓冲区，即使多重采样缓冲区不存储深度或模板值。但颜色缓冲区仍然会存在。

多重采样抗锯齿对于渲染多边形非常有价值，因为它不需要对隐藏表面消除进行排序，并且正确处理相邻多边形、物体轮廓甚至相交多边形。如果只渲染线段，则基本GL提供的“平滑”抗锯齿机制可能会产生更高质量的图像。此机制旨在允许在渲染单个场景期间交替使用多重采样和平滑抗锯齿技术。

如果SAMPLE_BUFFERS的值（见第9.2.3.1节）为1，那么所有基本图元的光栅化将发生变化，被称为多重采样光栅化。否则，基本光栅化被称为单样本光栅化。

在多重采样渲染期间，像素片段的内容以两种方式进行更改。首先，每个片段包括一个覆盖值，其值为SAMPLES位（见第9.2.3.1节）。

为了查询给定样本的着色样本位置（shading sample location），可以使用以下命令：

```c
void GetMultisamplefv(enum pname, uint index, float *val);
```

pname必须是SAMPLE_POSITION，而index对应于要返回位置的样本。样本位置以两个浮点值返回，分别在0到1之间，分别对应于该样本在GL像素空间中的x和y位置。因此，（0.5，0.5）对应于像素中心。如果多重采样模式没有固定的样本位置，返回的值可能只反映某些像素内样本的位置。

错误：

- 如果pname不是SAMPLE_POSITION，将生成INVALID_ENUM错误。
- 如果index大于或等于SAMPLES的值，将生成INVALID_VALUE错误。

其次，每个片段包括SAMPLES深度值和相关数据集，而不是在单样本光栅化模式下维护的单个深度值和相关数据集。一个实现可以选择为多个样本分配相同的相关数据。用于评估这些相关数据的位置可以位于像素内的任何位置，包括片段中心或任何样本位置。因此，每个像素片段包括整数x和y网格坐标、SAMPLES深度值和相关数据集，以及最多SAMPLES位的覆盖值。

多重采样光栅化可以通过使用目标MULTISAMPLE来调用Enable或Disable来启用或禁用。

如果MULTISAMPLE被禁用，所有基本图元的多重采样光栅化等同于单样本（片段中心）光栅化，只是片段覆盖值设置为完全覆盖。颜色和深度值以及纹理坐标集的值可以都设置为单样本光栅化分配的值，或者可以根据下面的多重采样光栅化的描述进行分配。

如果MULTISAMPLE被启用，所有基本图元的多重采样光栅化与单样本光栅化有很大的不同。理解每个帧缓冲中的像素都与其关联的样本位置是精确的位置，而不是区域或区域，每个位置都被称为样本点。这些样本点不一定对应于GetMultisamplefv返回的着色样本位置。它们的位置无法查询，可能位于像素被认为包围的单位正方形内或外。这些样本的数量可能不同于SAMPLES的值。此外，样本点的相对位置可能对于帧缓冲中的每个像素都相同，也可能不同。

如果MULTISAMPLE被启用，并且当前的程序对象包含一个带有一个或多个sample in限定符的输入变量的片段着色器，与这些变量相关的数据将被独立分配。每个样本的值必须在样本的位置进行评估。没有带有sample in限定符的其他变量的相关数据不需要独立评估每个样本。

如果样本位置因像素而异，则它们应该与窗口而不是屏幕边界对齐。否则，渲染结果将与窗口位置特定相关。

对于所有多重采样光栅化，14.2节中描述的不变性要求会有所放宽，因为样本位置可能是像素位置的函数。


## 14.3.1.1 样本着色

样本着色可以用来为每个片段指定要处理的最小唯一样本数量。样本着色通过使用目标SAMPLE_SHADING来调用Enable或Disable来进行控制。

如果MULTISAMPLE或SAMPLE_SHADING被禁用，样本着色没有效果。否则，对于每个片段，实现必须以一种依赖于实现的方式提供至少max（dmss×samples，1）组唯一的片段着色器输入。其中，mss是MIN_SAMPLE_SHADING_VALUE的值，samples是样本数（SAMPLES的值）。这些与样本相关联。MIN_SAMPLE_SHADING_VALUE的值由调用以下函数指定：

```c
void MinSampleShading( float value );
```

其中，value设置为所需的最小样本着色分数。指定时，value将被夹在[0,1]之间。可以通过使用pname MIN_SAMPLE_SHADING_VALUE来查询样本着色分数。

当样本着色分数为1.0时，为每个样本评估了单独的颜色和其他相关数据集，并且每组值都在样本位置进行评估。



## 14.4 点


绘制点是通过生成一组以点的顶点为中心的正方形或圆形形状的片段来实现的。每个顶点都有一个关联的点大小，用于控制该正方形或圆形的大小。

如果启用程序点大小模式，派生点大小将从着色器内建的gl_PointSize中获取，该值由以下方式写入：

- 如果几何着色器处于活动状态，由几何着色器写入；
- 如果启用了细分评估着色器，且没有几何着色器处于活动状态，则由细分评估着色器写入；
- 否则由顶点着色器写入。

这个值将被夹在实现相关的点大小范围内。如果写入gl_PointSize的值小于等于零，或者没有写入任何值到gl_PointSize中，结果是未定义的。

如果禁用程序点大小模式，派生点大小可以使用以下命令进行指定：

```c
void PointSize(float size);
```

size指定点的请求大小。默认值为1.0。

错误：

- 如果size小于等于零，将生成INVALID_VALUE错误。

程序点大小模式可以通过使用目标PROGRAM_POINT_SIZE来调用Enable或Disable来启用或禁用。

如果启用了多重采样，实现可以选择在允许点宽度低于给定阈值之前淡化点的alpha（见第17.2节），在这种情况下，光栅化点的宽度为：

width =
{
derived size, if derived size ≥ threshold
threshold, otherwise
(14.1)

淡化因子如下计算：

fade =
{
1, if derived size ≥ threshold
(derived size / (threshold * 2)), otherwise
(14.2)

点淡化阈值可以通过以下方式指定：

```c
void PointParameter{if}(enum pname, T param);
void PointParameter{if}v(enum pname, const T *params);
```

如果pname是POINT_FADE_THRESHOLD_SIZE，则param指定或params指向点淡化阈值。

数据转换按照第2.2.1节中规定的方式进行。

点精灵纹理坐标原点可以使用PointParameter*命令进行设置，其中pname是POINT_SPRITE_COORD_ORIGIN，param是LOWER_LEFT或UPPER_LEFT。默认值为UPPER_LEFT。

## 14.4.1 基本点光栅化

点光栅化为每个帧缓冲像素产生一个片段，其中心位于点的（xw, yw），其边长等于当前点大小。

在光栅化点精灵时生成的所有片段都被分配相同的相关数据，这些数据与对应于该点的顶点的相关数据相同。然而，片段着色器内建的gl_PointCoord包含点精灵纹理坐标。s点精灵纹理坐标沿点从左到右水平方向从零到一变化。如果POINT_SPRITE_COORD_ORIGIN为LOWER_LEFT，t坐标垂直从底部到顶部从零到一变化。否则，如果点精灵纹理坐标原点是UPPER_LEFT，t坐标垂直从顶部到底部从零到一变化。以下公式用于计算s和t点精灵纹理坐标：


其中size是点的大小，xf和yf是片段的（整数）窗口坐标，xw和yw是点的顶点的精确、未舍入的窗口坐标。

不需要支持所有点宽度，但必须提供宽度1.0。支持的宽度范围和范围内均匀分布的宽度是依赖于实现的。范围和间隔可以使用第22章中描述的查询机制获得。例如，如果宽度范围为0.1到2.0，间隔宽度为0.1，那么支持宽度0.1、0.2，...，1.9、2.0。还可以支持其他点宽度。这些宽度不必等距。如果请求了不受支持的宽度，将使用最接近的受支持的宽度。

## 14.4.2 点光栅化状态

控制点光栅化所需的状态包括浮点点宽度、一个指示是否启用了顶点程序点大小模式的位、点精灵纹理坐标原点的位和指定点淡化阈值大小的浮点值。

## 14.4.3 点多重采样光栅化

如果启用了MULTISAMPLE，并且SAMPLE_BUFFERS的值为1，则使用以下算法对点进行光栅化。点光栅化为每个帧缓冲像素产生一个片段，该像素中的一个或多个样本点与点的（xw, yw）周围的区域相交。这个区域是一个边长等于当前点宽度的正方形。与相交该区域的样本点对应的覆盖位为1，其他覆盖位为0。片段的所有与点关联的数据都是正在光栅化的点的相关数据。

支持的点大小集合等同于没有多重采样的点精灵的点大小集合。

## 14.5 线段

线段是由线带、线环或一系列单独的线段生成的。线段光栅化受多个变量控制。线宽可以通过调用以下命令进行设置：

```c
void LineWidth(float width);
```

使用适当的正浮点宽度控制光栅化线段的宽度。默认宽度为1.0。抗锯齿可以通过使用目标LINE_SMOOTH来调用Enable或Disable来启用或禁用。

## 14.6 多边形

多边形可以由三角形组成，这些三角形可以是三角带、三角扇或一系列单独的三角形。与点和线段一样，多边形的光栅化受到多个变量的控制。多边形抗锯齿可以通过调用`Enable`或`Disable`并指定`POLYGON_SMOOTH`目标来启用或禁用。 

## 14.6.1 基本多边形光栅化

多边形光栅化的第一步是确定多边形是背面还是正面。这一确定是基于在窗口坐标中计算的（裁剪或未裁剪的）多边形面积的符号而进行的。计算这个面积的一种方法是：

```c
void FrontFace( enum dir ); 

```

将`dir`设置为CCW（对应于窗口坐标中的逆时针方向）使用如上计算的`a`。将`dir`设置为CW（对应于顺时针方向）表示在使用`a`之前应翻转`a`的符号。前面的面确定需要一个状态位，初始设置为CCW。

如果`a`的符号（包括根据`FrontFace`确定的符号的可能翻转）为正，则多边形为正面；否则为背面。此确定与`CullFace`启用位和模式值一起用于决定是否光栅化特定多边形。`CullFace`模式通过以下方式设置：
```cpp
void CullFace( enum mode );
```

`mode`必须是`FRONT`、`BACK`或`FRONT_AND_BACK`。通过调用`Enable`或`Disable`并指定`CULL_FACE`目标来启用或禁用背面剔除。只有当禁用剔除或`CullFace`模式为`BACK`时，正面多边形才会被光栅化，而只有在禁用剔除或`CullFace`模式为`FRONT`时，背面多边形才会被光栅化。`CullFace`模式的初始设置为`BACK`。初始情况下，剔除是禁用的。

多边形光栅化决定生成哪些片段的规则称为点采样。通过获取多边形顶点的x和y窗口坐标形成多边形的二维投影。在多边形内部的片段中心会通过光栅化生成。对于位于多边形边缘上的片段中心，我们要求如果两个多边形分别位于共同边的两侧（具有相同的端点），则在光栅化期间只有一个多边形会生成该片段。

至于通过光栅化多边形生成的每个片段的相关数据，我们首先要指定如何为三角形的片段生成这些值。为三角形定义重心坐标。重心坐标是一组三个数字，a、b和c，每个数字位于[0, 1]范围内，且a + b + c = 1。这些坐标唯一地指定三角形内部或在三角形边界上的任何点p，如下：

p = apa + bpb + cpc，

其中pa、pb和pc是三角形的顶点。a、b和c可以如下计算：

a = A(ppbpc) / A(papbpc)，

b = A(ppapc) / A(papbpc)，

c = A(ppapb) / A(papbpc)。

这里A(lmn)表示具有顶点l、m和n的三角形在窗口坐标中的面积。通过这些重心坐标，可以用于为光栅化的多边形中的每个片段生成数据值。


## 14.6.3 抗锯齿

多边形抗锯齿通过在多边形内部与片段的正方形相交的地方产生片段来对多边形进行光栅化。在每个这样的片段处计算一个覆盖值，并保存此值以便根据第17.1节的描述应用。与片段相关的数据通过在片段正方形与多边形内部的交集区域上积分数据值并将这个积分值除以交集区域的面积来分配给片段。

对于完全位于多边形内部的片段正方形，可以使用片段中心的数据值，而不是在片段上积分数据值。

## 14.6.4 控制多边形光栅化的方法

多边形光栅化的解释由以下方法控制：

```c
void PolygonMode(enum face, enum mode);
```

其中`face`必须是`FRONT_AND_BACK`，表示`mode`指定的光栅化方法将替换正反两面多边形的光栅化方法。`mode`必须是`POINT`、`LINE`或`FILL`中的一个。使用`PolygonMode`并指定`POINT`将使多边形的顶点在光栅化时被视为使用`POINTS`模式绘制的效果。使用`LINE`将使边被视为线段进行光栅化。`FILL`是多边形光栅化的默认模式，对应于第14.6.1和14.6.3节中的描述。请注意，这些模式仅影响多边形的最终光栅化：特别是多边形的顶点在应用这些模式之前会被照明，多边形会在应用这些模式之前被裁剪和可能被消隐。

多边形抗锯齿仅适用于`PolygonMode`的`FILL`状态。对于`POINT`或`LINE`，分别适用点抗锯齿或线段抗锯齿。


## 14.6.5 Depth Offset

# mesa-18相关代码分析

```c

/**
 * 基本图元（点/线/三角形）光栅化信息
 */
struct pipe_rasterizer_state
{
   unsigned flatshade:1;                  // 是否启用平面着色
   unsigned light_twoside:1;              // 是否启用双面光照
   unsigned clamp_vertex_color:1;         // 是否对顶点颜色进行范围约束
   unsigned clamp_fragment_color:1;       // 是否对片段颜色进行范围约束
   unsigned front_ccw:1;                  // 前向面是逆时针方向（CCW）
   unsigned cull_face:2;                  // 剔除面的类型，可以是PIPE_FACE_x
   unsigned fill_front:2;                 // 前向面的填充模式，可以是PIPE_POLYGON_MODE_x
   unsigned fill_back:2;                  // 背向面的填充模式，可以是PIPE_POLYGON_MODE_x
   unsigned offset_point:1;               // 是否启用点的偏移
   unsigned offset_line:1;                // 是否启用线的偏移
   unsigned offset_tri:1;                 // 是否启用三角形的偏移
   unsigned scissor:1;                    // 是否启用裁剪区域
   unsigned poly_smooth:1;                // 是否启用多边形平滑
   unsigned poly_stipple_enable:1;        // 是否启用多边形点划
   unsigned point_smooth:1;               // 是否启用点平滑
   unsigned sprite_coord_mode:1;          // 精灵坐标模式，可以是PIPE_SPRITE_COORD_
   unsigned point_quad_rasterization:1;    // 点是否以四边形或点方式光栅化
   unsigned point_tri_clip:1;             // 大点是否裁剪为三角形或点
   unsigned point_size_per_vertex:1;      // 点大小是否在顶点着色器中计算
   unsigned multisample:1;                // 是否多重采样
   unsigned force_persample_interp:1;     // 是否强制逐样本插值
   unsigned line_smooth:1;                // 是否启用线平滑
   unsigned line_stipple_enable:1;        // 是否启用线划
   unsigned line_last_pixel:1;            // 最后一个像素是否绘制线
   unsigned conservative_raster_mode:2;   // 保守光栅化模式，可以是PIPE_CONSERVATIVE_RASTER_x

   /**
    * 使用基本图元的第一个顶点作为平面着色的初始顶点。
    */
   unsigned flatshade_first:1;

   unsigned half_pixel_center:1;           // 半像素居中
   unsigned bottom_edge_rule:1;            // 底部边界规则

   /*
    * 保守光栅化子像素精度偏差位数
    */
   unsigned subpixel_precision_x:4;
   unsigned subpixel_precision_y:4;

   /**
    * 当为真时，禁用光栅化并不写入任何像素。
    * 这仅在流输出（Stream Out）功能中才有意义。
    */
   unsigned rasterizer_discard:1;

   /**
    * 通过PIPE_CAP_TILE_RASTER_ORDER暴露。当为真时，
    * tile_raster_order_increasing_*指示光栅化器应以满足GL_MESA_tile_raster_order的要求
    * 渲染图块的顺序。
    */
   unsigned tile_raster_order_fixed:1;
   unsigned tile_raster_order_increasing_x:1;
   unsigned tile_raster_order_increasing_y:1;

   /**
    * 当为false时，禁用深度裁剪，深度值将在深度测试之前在每像素级别被夹紧。
    * 这取决于PIPE_CAP_DEPTH_CLIP_DISABLE。
    *
    * 如果不支持PIPE_CAP_DEPTH_CLIP_DISABLE_SEPARATE，则depth_clip_near等于depth_clip_far。
    */
   unsigned depth_clip_near:1;
   unsigned depth_clip_far:1;

   /**
    * 当为真时，剪裁空间中z轴范围为[0..1]（D3D）。当为假时范围为[-1, 1]（GL）。
    *
    * 注意：D3D将始终使用深度夹紧。
    */
   unsigned clip_halfz:1;

   /**
    * 当为真时，不缩放offset_units并使用相同规则处理unorm和float深度缓冲区（D3D9）。
    * 当为假时使用GL/D3D1X行为。
    * 这取决于PIPE_CAP_POLYGON_OFFSET_UNITS_UNSCALED。
    */
   unsigned offset_units_unscaled:1;

   /**
    * 启用用于裁剪半空间的位。
    * 这适用于用户裁剪平面和着色器裁剪距离。
    * 请注意，如果绑定的着色器导出任何裁剪距离，这些将替换所有用户裁剪平面，
    * 并且这里启用但未被着色器写入的裁剪半空间将被视为禁用。
    */
   unsigned clip_plane_enable:PIPE_MAX_CLIP_PLANES;

   unsigned line_stipple_factor:8;          // 线划因子 [1..256]
   unsigned line_stipple_pattern:16;

   /**
    * 用点坐标替换给定的TEXCOORD输入，最多8个输入。
    * 如果不支持TEXCOORD（包括PCOORD），则替换GENERIC输入。
    * 最多9个输入：8x GENERIC 以模拟TEXCOORD，1x GENERIC 以模拟PCOORD。
    */
   uint16_t sprite_coord_enable;           /* 0-7: TEXCOORD/GENERIC, 8: PCOORD */

   float line_width;                       // 线宽
   float point_size;                       // 点大小，当没有每顶点大小时使用
   float offset_units;                     // 偏移单位
   float offset_scale;                    

 // 偏移比例
   float offset_clamp;                     // 偏移夹紧
   float conservative_raster_dilate;
};
```



```
void GetMultisamplefv(enum pname, uint index, float *val);

```
